is.null(c(1,1,1))
initBstring = NULL
is.null(initBstring) == TRUE
is.null(initBstring)
TRUE && is.na(c(NA, "1"))
is.na(c(NA, "1"))
TRUE && any(is.na(c(NA, "1")))
TRUE && all(is.na(c(NA, "1")))
library(devtools)
install_github(repo = "saezlab/CNORode", build_vignettes = TRUE)
vignette("CNORode-vignette")
library(CellNOptR)
library(CNORode)
library(MEIGOR)
# MacNamara et al. 2012 case study:
data(PKN_ToyPB, package="CNORode")
data(CNOlist_ToyPB, package="CNORode")
# original and preprocessed network
plotModel(pknmodel, cnodata)
model = preprocessing(data = cnodata, model = pknmodel,
compression = T, expansion = T)
plotModel(model, cnodata)
plotCNOlist(CNOlist = cnodata)
# set initial parameters
ode_parameters=createLBodeContPars(model, LB_n = 1, LB_k = 0,
LB_tau = 0, UB_n = 4, UB_k = 1,
UB_tau = 1, default_n = 3, default_k = 0.5,
default_tau = 0.01, opt_n = FALSE, opt_k = TRUE,
opt_tau = TRUE, random = TRUE)
## Parameter Optimization
# essm
paramsSSm=defaultParametersSSm()
paramsSSm$local_solver = "DHC"
paramsSSm$maxtime = 600;
paramsSSm$maxeval = Inf;
paramsSSm$atol=1e-6;
paramsSSm$reltol=1e-6;
paramsSSm$nan_fac=0;
paramsSSm$dim_refset=30;
paramsSSm$n_diverse=1000;
paramsSSm$maxStepSize=Inf;
paramsSSm$maxNumSteps=10000;
transferFun=4;
paramsSSm$transfer_function = transferFun;
paramsSSm$lambda_tau=0
paramsSSm$lambda_k=0
paramsSSm$bootstrap=F
paramsSSm$SSpenalty_fac=0
paramsSSm$SScontrolPenalty_fac=0
# run the optimisation algorithm
opt_pars=parEstimationLBode(cnodata,model, method="essm",
ode_parameters=ode_parameters, paramsSSm=paramsSSm)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("CNORode")
library(CNORode)
ode_parameters=createLBodeContPars(integratedModel$model, LB_n = 1, LB_k = 0,
LB_tau = 0, UB_n = 3, UB_k = 1, UB_tau = 1, default_n = 3,
default_k = 0.5, default_tau = 0.01, opt_n = FALSE, opt_k = TRUE,
opt_tau = TRUE, random = TRUE)
data(integratedModel_toy, package="CNORfeeder")
data(CNOlistToy_Gene, package="CNORfeeder")
data(simData_toy,package="CNORfeeder")
ode_parameters=createLBodeContPars(integratedModel$model, LB_n = 1, LB_k = 0,
LB_tau = 0, UB_n = 3, UB_k = 1, UB_tau = 1, default_n = 3,
default_k = 0.5, default_tau = 0.01, opt_n = FALSE, opt_k = TRUE,
opt_tau = TRUE, random = TRUE)
result = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel,
ode_parameters = ode_parameters, paramsSSm = paramsSSm,
penFactor_k = 2, penFactorPIN_k = 0.1, penFactor_tau = 1)
library(CNORfeeder)
result = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel,
ode_parameters = ode_parameters, paramsSSm = paramsSSm,
penFactor_k = 2, penFactorPIN_k = 0.1, penFactor_tau = 1)
paramsSSm=defaultParametersSSm()
result = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel,
ode_parameters = ode_parameters, paramsSSm = paramsSSm,
penFactor_k = 2, penFactorPIN_k = 0.1, penFactor_tau = 1)
rm(list = ls())
library(CNORfeeder)
remove.packages("CNORfeeder")
install.packages("CNORfeeder/", repos = NULL, type="source")
library(CNORfeeder)
?runDynamicFeeder
data(integratedModel_toy, package="CNORfeeder")
data(CNOlistToy_Gene, package="CNORfeeder")
data(simData_toy,package="CNORfeeder")
## To be run with the recent version of the CNORode package: https://github.com/saezlab/CNORode
#
# library(CNORode)
#
# paramsSSm=defaultParametersSSm()
#
# ode_parameters=createLBodeContPars(integratedModel$model, LB_n = 1, LB_k = 0,
#                                    LB_tau = 0, UB_n = 3, UB_k = 1, UB_tau = 1, default_n = 3,
#                                    default_k = 0.5, default_tau = 0.01, opt_n = FALSE, opt_k = TRUE,
#                                    opt_tau = TRUE, random = TRUE)
#
# result = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel,
#                           ode_parameters = ode_parameters, paramsSSm = paramsSSm,
#                           penFactor_k = 2, penFactorPIN_k = 0.1, penFactor_tau = 1)
#
rm(list = ls())
?integrateLinks
data(feederObject_toy,package="CNORfeeder")
data(CNOlistToy_Gene, package="CNORfeeder")
data(CNOlistToy_Gene, package="CNORfeeder")
integratedModel = integrateLinks(feederObject = feederObject, cnolist = cnolist,
database = NULL)
rm(list = ls())
?identifyMisfitIndices
data(ToyModel_Gene, package="CNORfeeder")
data(CNOlistToy_Gene, package="CNORfeeder")
data(indices,package="CNORfeeder")
data(database, package="CNORfeeder")
indices = identifyMisfitIndices(cnolist = cnolist, model = model,
simData = simData, mseThresh = 0.05)
data(ToyModel_Gene, package="CNORfeeder")
data(CNOlistToy_Gene, package="CNORfeeder")
data(indices,package="CNORfeeder")
data(database, package="CNORfeeder")
indices = identifyMisfitIndices(cnolist = cnolist, model = model,
simData = simData, mseThresh = 0.05)
rm(list = ls())
data(ToyModel_Gene, package="CNORfeeder")
data(CNOlistToy_Gene, package="CNORfeeder")
data(indices,package="CNORfeeder")
data(database, package="CNORfeeder")
data(simData_toy,package="CNORfeeder")
indices = identifyMisfitIndices(cnolist = cnolist, model = model,
simData = simData, mseThresh = 0.05)
indices$indices
rm(list = ls())
data(ToyModel_Gene, package="CNORfeeder")
data(CNOlistToy_Gene, package="CNORfeeder")
data(simData_toy,package="CNORfeeder")
feederObject = buildFeederObjectDynamic(model = model, cnolist = cnolist,
indices = NULL, database = NULL,
DDN = TRUE, pathLength = 2)
remove.packages("CNORfeeder")
rm(list = ls())
remove.packages("CNORfeeder")
install.packages("CNORfeeder/", repos = NULL, type="source")
library(CNORfeeder)
?buildFeederObjectDynamic
data(ToyModel_Gene, package="CNORfeeder")
data(CNOlistToy_Gene, package="CNORfeeder")
data(simData_toy,package="CNORfeeder")
feederObject = buildFeederObjectDynamic(model = model, cnolist = cnolist,
indices = NULL, database = NULL,
DDN = TRUE, pathLength = 2)
rm(list = ls())
?identifyMisfitIndices
data(ToyModel_Gene, package="CNORfeeder")
data(CNOlistToy_Gene, package="CNORfeeder")
data(indices,package="CNORfeeder")
data(database, package="CNORfeeder")
data(simData_toy,package="CNORfeeder")
indices = identifyMisfitIndices(cnolist = cnolist, model = model,
simData = simData, mseThresh = 0.05)
rm(list = ls())
?integrateLinks
data(feederObject_toy,package="CNORfeeder")
data(CNOlistToy_Gene, package="CNORfeeder")
data(CNOlistToy_Gene, package="CNORfeeder")
integratedModel = integrateLinks(feederObject = feederObject, cnolist = cnolist,
database = NULL)
rm(list = ls())
?runDynamicFeeder
data(integratedModel_toy, package="CNORfeeder")
data(CNOlistToy_Gene, package="CNORfeeder")
data(simData_toy,package="CNORfeeder")
## To be run with the recent version of the CNORode package:
## https://github.com/saezlab/CNORode
#
# library(CNORode)
#
# paramsSSm=defaultParametersSSm()
#
# ode_parameters=createLBodeContPars(integratedModel$model, LB_n = 1, LB_k = 0,
#                                    LB_tau = 0, UB_n = 3, UB_k = 1, UB_tau = 1, default_n = 3,
#                                    default_k = 0.5, default_tau = 0.01, opt_n = FALSE, opt_k = TRUE,
#                                    opt_tau = TRUE, random = TRUE)
#
# result = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel,
#                           ode_parameters = ode_parameters, paramsSSm = paramsSSm,
#                           penFactor_k = 2, penFactorPIN_k = 0.1, penFactor_tau = 1)
#
rm(list = ls())
library(BiocCheck)
BiocCheck("CNORfeeder")
library(CellNOptR)
?ilpBinaryT1
library(BiocCheck)
getwd()
BiocCheck(package = "~/Documents/GitHub/CellNOptR/")
BiocCheck(package = "~/Documents/GitHub/CellNOptR/")
remove.packages("CellNOptR")
library(devtools)
install_github(repo = "saezlab/CellNOptR", build_vignettes = TRUE)
vignette("CellNOptR-vignette")
library(CellNOptR)
?createAndRunILP
remove.packages("CellNOptR")
library(devtools)
install_github(repo = "saezlab/CellNOptR", ref = "bioc_guidelines", build_vignettes = TRUE)
install_github(repo = "saezlab/CellNOptR", ref = "bioc_guidelines", build_vignettes = TRUE)
vignette("CellNOptR-vignette")
library(CellNOptR)
?createAndRunILP
?createILPBitstringAll
?create_binaries
?crossvalidateBoolean
?ilpBinaryT1
?ilpBinaryT2
?ilpBinaryTN
?invokeCPLEX
?writeFile
?writeObjectiveFunction
?write_bounds
?write_constraints
remove.packages("CellNOptR")
library(devtools)
install_github(repo = "saezlab/CellNOptR", ref = "bioc_guidelines", build_vignettes = TRUE)
library(CellNOptR)
?ilpBinaryT1
# Toy Exampple
data("ToyModel", package="CellNOptR")
data("CNOlistToy", package="CellNOptR")
pknmodel = ToyModel
cnolist = CNOlist(CNOlistToy)
model = preprocessing(data = cnolist, model = pknmodel, compression = TRUE, expansion = TRUE)
plotModel(model = model, CNOlist = cnolist)
resILP = ilpBinaryT1(cnolist = cnolist, model = model, cplexPath = "~/Documents/cplex")
resILP
?crossvalidateBoolean
rm(list = ls())
data("ToyModel", package="CellNOptR")
data("CNOlistToy", package="CellNOptR")
pknmodel = ToyModel
cnodata = CNOlist(CNOlistToy)
# original and preprocessed network
plotModel(pknmodel,cnodata)
model = preprocessing(data = cnodata,
model = pknmodel,
compression = TRUE,
expansion = TRUE)
plotModel(model,cnodata)
# original CNOlist contains many timepoints, we use only a subset
plot(cnodata)
selectedTime = c(0,10)
cnodata_prep = cutCNOlist(cnodata,
model = model,
cutTimeIndices = which(!cnodata@timepoints %in% selectedTime))
plot(cnodata_prep)
# optimise and show results
opt = gaBinaryT1(CNOlist = cnodata_prep,model = model,verbose = FALSE)
# 10-fold crossvalidation using T1 data
# We use only T1 data for crossvalidation, because data in the T0 matrix is not independent.
# All rows of data in T0 describes the basal condition.
# Crossvalidation produce some text in the command window:
## Not run:
library(doParallel)
registerDoParallel(cores=3)
R=crossvalidateBoolean(CNOlist = cnodata_prep,
model = model,
type="datapoint",
nfolds=10,
parallel = TRUE)
R
?createAndRunILP
library(BiocCheck)
getwd()
BiocCheck("CNORfeeder")
rm(list = ls())
install.packages("catnet")
install.packages("minet")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("minet")
library(BiocCheck)
BiocCheck(package = "~/Documents/GitHub/CARNIVAL/")
BiocCheck(package = "~/Documents/GitHub/CARNIVAL/")
library(BiocCheck)
BiocCheck(package = "Documents/GitHub/CARNIVAL/")
BiocCheck(package = "Documents/GitHub/CARNIVAL/")
remove.packages("progeny")
library(devtools)
install_github(repo = "saezlab/progeny", build_vignettes = TRUE)
install_github(repo = "saezlab/progeny", build_vignettes = TRUE)
install_github(repo = "saezlab/dorothea", build_vignettes = TRUE)
install_github(repo = "saezlab/progeny", build_vignettes = TRUE)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
# The following initializes usage of Bioc devel
BiocManager::install(version='devel')
BiocManager::install("progeny")
library(progeny)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
# The following initializes usage of Bioc devel
BiocManager::install(version='devel')
BiocManager::install("dorothea")
library(CARNIVAL)
load(file = system.file("toy_inputs_ex1.RData",
package="CARNIVAL"))
load(file = system.file("toy_measurements_ex1.RData",
package="CARNIVAL"))
load(file = system.file("toy_network_ex1.RData",
package="CARNIVAL"))
# lpSolve
result = runCARNIVAL(inputObj = toy_inputs_ex1, measObj = toy_measurements_ex1,
netObj = toy_network_ex1)
result
library(CARNIVAL) # load CARNIVAL library
load(file = system.file("toy_measurements_ex2.RData",
package="CARNIVAL"))
load(file = system.file("toy_network_ex2.RData",
package="CARNIVAL"))
# lpSolve
result = runCARNIVAL(measObj = toy_measurements_ex2, netObj = toy_network_ex2)
result
vignette("progeny")
remove.packages("CARNIVAL")
library(devtools)
rm(list = ls())
install_github(repo = "saezlab/CARNIVAL-Bioconductor-Dev", build_vignettes = TRUE)
vignette("CARNIVAL-vignette")
remove.packages("CARNIVAL")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
# The following initializes usage of Bioc devel
BiocManager::install(version='devel')
BiocManager::install("CARNIVAL")
library(CARNIVAL)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
# The following initializes usage of Bioc devel
BiocManager::install(version='devel')
BiocManager::install("CARNIVAL")
library(readr)
Group <- read_csv("~/Documents/GitHub/EDN_phospho/Background-Network/inst/Group.csv")
View(Group)
kk <- as.matrix(x = Group)
View(kk)
write.table(x = kk, file = "kk.txt", quote = FALSE, sep = "\t", row.names = FALSE, col.names = TRUE)
getwd()
setw
setwd("~/Documents/GitHub/Hong_etal_2020/")
## Loading the packages required
library(readr)
library(ggplot2)
library(reshape)
library(pheatmap)
library(gridExtra)
library(grid)
library(cowplot)
library(ggrepel)
library(FactoMineR)
library(factoextra)
## Loading the data and creating sample groups
load(file = "src/Yinfeng_processed_normalized_gene_counts_wt.RData")
groups <- c("GM-CSF", "M-CSF", "Hox", "GM-CSF", "M-CSF", "Hox", "GM-CSF", "M-CSF", "Hox")
names(groups) <- colnames(data)
## PCA analysis of samples
data.pca <- t(data)
data.pca <- cbind(data.pca, as.matrix(groups))
colnames(data.pca)[ncol(data.pca)] <- "Group"
data.pca <- as.data.frame(data.pca)
data.pca[, 1:(ncol(data.pca)-1)] <- lapply(data.pca[, 1:(ncol(data.pca)-1)], function(x) as.numeric(as.character(x)))
res.pca <- prcomp(data.pca[, -ncol(data.pca)], scale. = TRUE)
res.plot <-  as.data.frame(cbind(res.pca$x[, 1], res.pca$x[, 2], as.character(data.pca$Group), rownames(data.pca)))
res.plot[, 1:2] <- lapply(res.plot[, 1:2], function(x) as.numeric(as.character(x)))
res.plot[, 3:4] <- lapply(res.plot[, 3:4], function(x) as.character(x))
colnames(res.plot) <- c("pc1", "pc2", "Group", "sample")
percentages <- ((res.pca$sdev)^2 / sum(res.pca$sdev^2)*100)[1:2]
pp <- ggplot(res.plot, aes(x=pc1, y=pc2, color=Group)) +
geom_point(size=7, alpha = 0.5) +
scale_alpha_discrete(range=c(0.3, 1.0)) +
#geom_path(arrow=arrow()) +
theme_minimal() +
xlab(paste0("PC1 (", round(x = percentages[1], digits = 2), "%)")) +
ylab(paste0("PC1 (", round(x = percentages[1], digits = 2), "%)")) +
xlim(c(-max(abs(res.pca$x[, 1])),max(abs(res.pca$x[, 1])))) +
ylim(c(-max(abs(res.pca$x[, 2])),max(abs(res.pca$x[, 2])))) + theme(legend.position = "none") +
geom_text_repel(data = res.plot, aes(label=sample))
plot(pp)
## Correlation heatmap of samples
pheatmap(mat = cor(x = data, method = "spearman"), main = "Spearman Correlation of Samples",
fontsize_number = 5, fontsize = 15)
## Loading the packages required
library(readr)
library(ggplot2)
library(reshape)
library(pheatmap)
library(gridExtra)
library(grid)
library(cowplot)
library(ggrepel)
## Loading the data and creating sample groups
load(file = "src/Yinfeng_processed_normalized_gene_counts_wt.RData")
groups <- c("GM-CSF", "M-CSF", "Hox", "GM-CSF", "M-CSF", "Hox", "GM-CSF", "M-CSF", "Hox")
names(groups) <- colnames(data)
## PCA analysis of samples
data.pca <- t(data)
data.pca <- cbind(data.pca, as.matrix(groups))
colnames(data.pca)[ncol(data.pca)] <- "Group"
data.pca <- as.data.frame(data.pca)
data.pca[, 1:(ncol(data.pca)-1)] <- lapply(data.pca[, 1:(ncol(data.pca)-1)], function(x) as.numeric(as.character(x)))
res.pca <- prcomp(data.pca[, -ncol(data.pca)], scale. = TRUE)
res.plot <-  as.data.frame(cbind(res.pca$x[, 1], res.pca$x[, 2], as.character(data.pca$Group), rownames(data.pca)))
res.plot[, 1:2] <- lapply(res.plot[, 1:2], function(x) as.numeric(as.character(x)))
res.plot[, 3:4] <- lapply(res.plot[, 3:4], function(x) as.character(x))
colnames(res.plot) <- c("pc1", "pc2", "Group", "sample")
percentages <- ((res.pca$sdev)^2 / sum(res.pca$sdev^2)*100)[1:2]
pp <- ggplot(res.plot, aes(x=pc1, y=pc2, color=Group)) +
geom_point(size=7, alpha = 0.5) +
scale_alpha_discrete(range=c(0.3, 1.0)) +
#geom_path(arrow=arrow()) +
theme_minimal() +
xlab(paste0("PC1 (", round(x = percentages[1], digits = 2), "%)")) +
ylab(paste0("PC1 (", round(x = percentages[1], digits = 2), "%)")) +
xlim(c(-max(abs(res.pca$x[, 1])),max(abs(res.pca$x[, 1])))) +
ylim(c(-max(abs(res.pca$x[, 2])),max(abs(res.pca$x[, 2])))) + theme(legend.position = "none") +
geom_text_repel(data = res.plot, aes(label=sample))
plot(pp)
## Correlation heatmap of samples
pheatmap(mat = cor(x = data, method = "spearman"), main = "Spearman Correlation of Samples",
fontsize_number = 5, fontsize = 15)
library(readr)
## Loading the packages required
library(readr)
library(ggplot2)
library(reshape)
library(pheatmap)
library(gridExtra)
library(grid)
library(cowplot)
library(ggrepel)
## Loading the data and creating sample groups
load(file = "src/Yinfeng_processed_normalized_gene_counts_wt.RData")
groups <- c("GM-CSF", "M-CSF", "Hox", "GM-CSF", "M-CSF", "Hox", "GM-CSF", "M-CSF", "Hox")
names(groups) <- colnames(data)
## PCA analysis of samples
data.pca <- t(data)
data.pca <- cbind(data.pca, as.matrix(groups))
colnames(data.pca)[ncol(data.pca)] <- "Group"
data.pca <- as.data.frame(data.pca)
data.pca[, 1:(ncol(data.pca)-1)] <- lapply(data.pca[, 1:(ncol(data.pca)-1)], function(x) as.numeric(as.character(x)))
res.pca <- prcomp(data.pca[, -ncol(data.pca)], scale. = TRUE)
res.plot <-  as.data.frame(cbind(res.pca$x[, 1], res.pca$x[, 2], as.character(data.pca$Group), rownames(data.pca)))
res.plot[, 1:2] <- lapply(res.plot[, 1:2], function(x) as.numeric(as.character(x)))
res.plot[, 3:4] <- lapply(res.plot[, 3:4], function(x) as.character(x))
colnames(res.plot) <- c("pc1", "pc2", "Group", "sample")
percentages <- ((res.pca$sdev)^2 / sum(res.pca$sdev^2)*100)[1:2]
pp <- ggplot(res.plot, aes(x=pc1, y=pc2, color=Group)) +
geom_point(size=7, alpha = 0.5) +
scale_alpha_discrete(range=c(0.3, 1.0)) +
#geom_path(arrow=arrow()) +
theme_minimal() +
xlab(paste0("PC1 (", round(x = percentages[1], digits = 2), "%)")) +
ylab(paste0("PC1 (", round(x = percentages[1], digits = 2), "%)")) +
xlim(c(-max(abs(res.pca$x[, 1])),max(abs(res.pca$x[, 1])))) +
ylim(c(-max(abs(res.pca$x[, 2])),max(abs(res.pca$x[, 2])))) + theme(legend.position = "none") +
geom_text_repel(data = res.plot, aes(label=sample))
plot(pp)
## Correlation heatmap of samples
pheatmap(mat = cor(x = data, method = "spearman"), main = "Spearman Correlation of Samples",
fontsize_number = 5, fontsize = 15)
## Loading the packages required
library(readr)
library(ggplot2)
library(reshape)
library(pheatmap)
library(gridExtra)
library(grid)
library(cowplot)
library(ggrepel)
## Loading the data and creating sample groups
load(file = "src/Yinfeng_processed_normalized_gene_counts_wt.RData")
groups <- c("GM-CSF", "M-CSF", "Hox", "GM-CSF", "M-CSF", "Hox", "GM-CSF", "M-CSF", "Hox")
names(groups) <- colnames(data)
## PCA analysis of samples
data.pca <- t(data)
data.pca <- cbind(data.pca, as.matrix(groups))
colnames(data.pca)[ncol(data.pca)] <- "Group"
data.pca <- as.data.frame(data.pca)
data.pca[, 1:(ncol(data.pca)-1)] <- lapply(data.pca[, 1:(ncol(data.pca)-1)],
function(x) as.numeric(as.character(x)))
res.pca <- prcomp(data.pca[, -ncol(data.pca)], scale. = TRUE)
res.plot <-  as.data.frame(cbind(res.pca$x[, 1], res.pca$x[, 2],
as.character(data.pca$Group), rownames(data.pca)))
res.plot[, 1:2] <- lapply(res.plot[, 1:2], function(x) as.numeric(as.character(x)))
res.plot[, 3:4] <- lapply(res.plot[, 3:4], function(x) as.character(x))
colnames(res.plot) <- c("pc1", "pc2", "Group", "sample")
percentages <- ((res.pca$sdev)^2 / sum(res.pca$sdev^2)*100)[1:2]
pp <- ggplot(res.plot, aes(x=pc1, y=pc2, color=Group)) +
geom_point(size=7, alpha = 0.5) +
scale_alpha_discrete(range=c(0.3, 1.0)) +
#geom_path(arrow=arrow()) +
theme_minimal() +
xlab(paste0("PC1 (", round(x = percentages[1], digits = 2), "%)")) +
ylab(paste0("PC1 (", round(x = percentages[1], digits = 2), "%)")) +
xlim(c(-max(abs(res.pca$x[, 1])),max(abs(res.pca$x[, 1])))) +
ylim(c(-max(abs(res.pca$x[, 2])),max(abs(res.pca$x[, 2])))) +
theme(legend.position = "none") +
geom_text_repel(data = res.plot, aes(label=sample))
plot(pp)
## Correlation heatmap of samples
pheatmap(mat = cor(x = data, method = "spearman"),
main = "Spearman Correlation of Samples",
fontsize_number = 5, fontsize = 15)
